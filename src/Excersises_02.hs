module Excersises_02 where

import qualified Data.Time as Time
import qualified Data.Map as Map
import Data.Maybe

--datatype in record syntax
data Person = Male { firstName :: String, lastName :: String } | Female { firstName :: String, lastName :: String }

--function that takes in a female, uses person@ for the entire pattern (Female _ _ )
--function that takes in a male uses standard datatype sytnax, also works as it should
greet :: Person -> String
greet person@(Female _ _) = "Hello, Miss " ++ (firstName person) ++ " " ++ (lastName person)
greet (Male firstName lastName) = "Hello, Mister " ++ firstName ++ " " ++ lastName

main_10 = do

    --equivalent invocations
    print $ greet $ Male { lastName="Doe", firstName="John" }
    print $ greet $ Male "John" "Doe"
    print $ greet $ Female "Jane" "Doe"
    return ()


--generic type, 'a' can be of any type
data Nullable a = Null | Value a

printn :: (Show a) => Nullable a -> IO ()
printn (Value a) = print a
printn Null = print "NULL"

getnull :: Nullable a
getnull = Null

--construction of a custom Vector datatype
--functions are defined with infix notation `nameOfFunction`
data Vector a = Vector a a a deriving (Show)
vplus :: (Num t) => Vector t -> Vector t -> Vector t
(Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n)

vectMult :: (Num t) => Vector t -> t -> Vector t
(Vector i j k) `vectMult` m = Vector (i*m) (j*m) (k*m)

scalarMult :: (Num t) => Vector t -> Vector t -> t
(Vector i j k) `scalarMult` (Vector l m n) = i*l + j*m + k*n


--making our custom type implement a typeclass
data Person2 = Person2 { name :: String, age :: Int, dateOfBirth :: Time.Day } deriving (Eq, Show, Read)

--enum type
data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Show, Read, Bounded, Enum, Ord)

main_20 :: IO ()
main_20 = do

    printn $ Value 5
    printn $ Value "thing"
    printn $ (Null :: Nullable Int)

    --Maybe is Prelude's nullable
    print $ Just 5
    print $ (Nothing :: Maybe Int)

    --default behavior for Show is generated by compiler
    print $ Person2 "Tino" 30 (Time.fromGregorian 1983 12 22)

    --parsing from String (specify reads return type)
    let thing = read "Wednesday" :: Day
    print thing

    --minBound and maxBound return biggest and smallest value for Day datatype
    print (minBound :: Day)
    print (maxBound :: Day)

    --since we are part of Enum we can do this
    print $ succ Monday
    print $ pred Wednesday
    print $ [Monday .. Sunday]

    return ()


--aliasing typenames
type Pair a = (a,a)
type PairInt = Pair Int

--we can use type alias, also demonstrate function that does IO
printPair :: PairInt -> IO()
printPair (a,b) = do
            print "PAIR"
            print $ "    " ++ (show a) ++ ":" ++ (show b)

--doing lookups in a map, using case
findAndPrintValue :: (Ord a, Show b) => a -> Map.Map a b -> IO()
findAndPrintValue key map = let res = Map.lookup key map in
                                case res of
                                Nothing -> print "Nothing found!!!"
                                Just b -> print b


main_30 :: IO()
main_30 = do

    let b = (3,4)
    printPair b

    --maps and lookups
    let mapping = Map.fromList [(0,"a"),(1,"b"),(2,"c")]
    findAndPrintValue 0 mapping
    findAndPrintValue 1 mapping
    findAndPrintValue 5 mapping

    return ()


--definition of our own typeclass
class XMLSerializable arg where
    serializeToXML :: arg -> String
    deserializeFromXML :: String -> arg

--implement Person type as instance of XMLSerializable typeclass
instance XMLSerializable Person where
    serializeToXML a = let name = "<name>" ++ (firstName a) ++ " " ++ (lastName a) ++ "</name>"
                           persontype = case a of
                                    Male _ _ -> "<type>Male</type>"
                                    Female _ _ -> "<type>Female</type>"
                        in "<person>" ++ name ++ persontype ++ "</person>"
    deserializeFromXML xml = Male "fake" "fake"

--implement serialization for a pair of values, each of which must be itself serializable
--we use typeclass constraint (XML.. a, XML.. b) =>
instance (XMLSerializable a, XMLSerializable b) => XMLSerializable (a,b) where
    serializeToXML (arg1,arg2) = (serializeToXML arg1) ++ (serializeToXML arg2)
    deserializeFromXML xml = ((deserializeFromXML xml) , (deserializeFromXML xml))

--implementing YesNo behavior for various types
class YesNo a where
    is :: a -> Bool

--basic stuff
instance YesNo Int where
    is 0 = False
    is _ = True

instance YesNo [a] where
    is [] = False
    is _ = True

--id is a standard identity function (id a = a)
instance YesNo Bool where
    is = id

--when implementing YesNo for Maybe, use False when Nothing, otherwise use value contained in Just
instance (YesNo a) => YesNo (Maybe a) where
    is Nothing = False
    is (Just arg) = is arg

--if a type T is instance of Functor typeclass, it has to implement fmap function that takes in (a -> b) and translates T a to T b
--these are test function to show how it does that
addOne :: Int -> Int
addOne = (+ 1)
addOneAndShow :: Int -> String
addOneAndShow = show . addOne

main :: IO()
main = do

    print $ serializeToXML $ Male "tino" "juricic"
    print $ serializeToXML ((deserializeFromXML "lalalal") :: Person)

    print $ is (0 :: Int)
    print $ is [1]
    print $ is (Nothing :: Maybe Int)

    --use fmap (map that can work on types implementing Functor typeclass)
    --Functor typeclass defines a function in which Type a goes into Type b when we have function (a -> b), or to put it like this: given contructor f, fmap is (a -> b) -> f a -> f b
    --list implements a functor
    print $ [1,2,3]
    print $ fmap addOneAndShow [1,2,3]

    return ()






